<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[我眼中的Android MVC,MVP,MVVM]]></title>
      <url>%2F2017%2F06%2F01%2Fandroid-architecture-think%2F</url>
      <content type="text"><![CDATA[纸上得来终觉浅,绝知此事要躬行 一直没有认真研究过 MVVM 这次花了点时间理解了一下这种架构,正好集齐了三种架构模式,这里就简单的谈一下我的理解吧 mvc首先说一下mvc,要说来android本身就是一种 mvc 的架构设计,我们采用xml进行view界面的编写(view),用 retrofit等网络框架进行数据访问(model),然后在activity 或者是fragment里面进行数据绑定逻辑处理(controller),因为我们所有的交互逻辑和数据处理都会在activity或者fragment里面进行,这样会导致我们的这两部分的代码会越来越多,使项目变的难以管理,也不好进行新的扩展 mvp因为mvc的诸多问题,所以后来提出了新的架构 mvp 和 mvc 相比更进一层的进行了解耦合,利用 prsenter 这个桥梁让 view,和 model 间接通信把所有的交互逻辑都交给了 presenter 处理,而view 只负责 ui 部分的展示,model 负责数据这一块,presenter 和 view 之间的通信通过接口实现. mvp 使用也有一些问题,比如过多接口的定义使得一个小项目也要定义过多的接口,写很多代码 mvvmmvvm 配合 android 推出的 data binding 库进行使用效果良好,这里和mvp的区别在于viewModel 直接通过data binding动态和viw进行绑定,而不需要再用接口进行实现,代码更加的清晰明了.也更加的便于进行单元测试 最后这三种架构都有一个model 其实这一部分所有的架构都是通用的我们完全可以把这一部分定义好,然后 controller , presenter ,viewmodel,三者之间controller 很难扩展或者复用,presenter次之,viewmodel 我认为是完全可以复用的我们只需要改变view层就行 当然几种架构各有专长,我们应该根据自己的需要选择自己需要的架构]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用 Kotlin 进行 android 开发]]></title>
      <url>%2F2017%2F05%2F21%2Fuse-kotlin-develop-android%2F</url>
      <content type="text"><![CDATA[追一波热度 今天我也来追一波热度的吧，论如何利用 Android Studio 用 Kotlin 开发 Android，废话少说直接进入正题话说 Android Studio 3.0已经和Kotlin plugin进行了捆绑，但是要是 3.0 以下咋办呢？，那也很简单 第一步安装插件首先打开Android Studio选择 File -&gt; Settings -&gt; Plugins -&gt; install JetBrins Plugins ，然后搜索 Kotlin选择安装，安装完成之后重启 Android Studio，到这里插件就安装完成了，下面就开心的开发项目吧 第二步创建你的项目这一步很简单，平时怎么创建项目这里就怎么创建，然后呢选择 Code-&gt;Converting Java code to Kotlin，ok到了这里代码已经转换为 Kotlin 了 最后一步稍稍配置一下项目在 Android Studio 菜单栏选择 Tools -&gt; Kotlin -&gt; Configure Kotlin in Project，然后选中ALL modules contating Kotlin files： app，点击确定。到这里重新再编译一下你的项目，就可以愉快的用 Kotlin 开发 Android 了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[模仿知乎android端分享功能]]></title>
      <url>%2F2017%2F01%2F18%2Flmitate-zhihu-share%2F</url>
      <content type="text"><![CDATA[向前跑的时候，也要记得回头看看 漫长的考试周终于结束了，我也有时间继续折腾Android了。前段时间在做团队应用的时候需求有一个分享功能。我想这还不简单，直接采用系统级分享完事儿。结果问题来了，发现微信对于系统级的分享只支持分享图片到朋友圈，并不支持文字等其他内容，如果要想分享其他内容到朋友圈就必须集成微信的sdk。 于是乎我就想有木有办法，既能集成第三方分享又能不抛弃系统级分享呢？然后看到知乎貌似就实现了这样的效果还很原生呢。既然知乎能实现，那么我也就有办法。以下是实现效果. 我们知道实现系统级分享时一般是使用如下代码12345Intent sendIntent = new Intent();sendIntent.setAction(Intent.ACTION_SEND);sendIntent.putExtra(Intent.EXTRA_TEXT, "This is my text to send.");sendIntent.setType("text/plain");startActivity(Intent.createChooser(sendIntent, getResources().getText(R.string.send_to))); 上述代码通过给Intent设置`Intent.ACTION_SENDaction然后再通过Intent.createChooser()方法就能调起手机里具有接受来自其他应用分享的应用。 既然如此，那么我也可以通过上述的方法拿到手机里这部分应用，话不多说开干。首先模仿上述代码来获取到手机里的这部分应用1234567891011121314final Intent intent = new Intent(Intent.ACTION_SEND); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.setType("*/*"); PackageManager pm = this.getPackageManager(); List&lt;ResolveInfo&gt; resInfos = pm.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY); shareAppItems = new LinkedList&lt;&gt;(); for (ResolveInfo info : resInfos) &#123; CharSequence appLabel = info.loadLabel(pm);//获取应用当前标签名 Drawable appIcon = info.loadIcon(pm);//获取可分享应用的icon String appName = info.activityInfo.name;//当前activity的包名 String packageName = info.activityInfo.packageName;//当前应用包名 ShareAppItem shareAppItem = new ShareAppItem(appLabel, appIcon, appName, packageName); shareAppItems.add(shareAppItem); &#125; 我们根据PackageManager来查询手机中已安装的具有分享功能的App，并且返回ResolveInfo类型的List以获取应用的相关信息 最后根据应用包名指定分享方式,比如分享到微信用微信给的Sdk来完成,然后系统内默认的采用系统级分享123456789101112131415161718/** * 根据应用的包名确定具体的分享方案 * * @param position */ @Override public void onItemClick(int position) &#123; switch (shareAppItems.get(position).getAppName()) &#123; case "com.tencent.mm.ui.tools.ShareImgUI": Toast.makeText(MainActivity.this, "分享到微信", Toast.LENGTH_SHORT).show(); break; case "com.tencent.mm.ui.tools.ShareToTimeLineUI": Toast.makeText(MainActivity.this, "分享到微信朋友圈", Toast.LENGTH_SHORT).show(); break; default: share(position, shareAppItems); &#125; &#125; 核心内容就是这么多到此,全部完成。然后这里获取到了腾讯家的一些包名或许有用1234567com.tencent.mm.ui.tools.ShareImgUI //分享给好友com.tencent.mm.ui.tools.AddFavoriteUIcom.tencent.mm.ui.tools.ShareToTimeLineUI //分享到朋友圈com.tencent.mobileqq.activity.JumpActivitycom.tencent.mobileqq.activity.qfileJumpActivitycooperation.qqfav.widget.QfavJumpActivity Demo地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[navigationView的使用]]></title>
      <url>%2F2016%2F10%2F10%2Fandroid-navigationview%2F</url>
      <content type="text"><![CDATA[好记性，不如烂笔头 最近自己做的一个练手项目用到了，navigationView，其中也遇到了一些问题，今天在这里总结一下他的用法。 First 准备工作首先在app的build.gradle文件里添加依赖compile&#39;com.android.support:design:24.1.1 Second 在xml中文件使用平时使用我们都是将navigationView置于DrawerLayout中,所以我们这样定义布局 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true"&gt;&lt;!-- 内容区域 --&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;include android:id="@+id/toolbar_container" layout="@layout/toolbar" /&gt; &lt;include android:id="@+id/container" layout="@layout/drawer_content" /&gt; &lt;/LinearLayout&gt;&lt;!-- navigationView --&gt; &lt;android.support.design.widget.NavigationView android:id="@+id/navgation_view" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="left" app:headerLayout="@layout/nav_header" app:menu="@menu/drawer" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 在上面的代码我们可以看到navigationView包含了一个header布局和一个menu作用如图： 其中nav_header布局通过app:headerLayout=&quot;@layout/nav_header&quot;添加，nav_header布局如下 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="192dp" android:background="@color/colorPrimary" android:gravity="bottom" android:orientation="vertical"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="每日一图" android:textColor="@android:color/white" /&gt;&lt;/LinearLayout&gt; drawer通过app:menu=&quot;@menu/drawer&quot;添加,drawer代码 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;group&gt; &lt;item android:id="@+id/nav_today_photo" android:checkable="true" android:icon="@drawable/ic_photo_today" android:title="@string/today_photo" /&gt; &lt;item android:id="@+id/nav_more_photo" android:checkable="true" android:icon="@drawable/ic_photo_more" android:title="@string/more_photo" /&gt; &lt;/group&gt; &lt;item android:title="@string/others"&gt; &lt;menu&gt; &lt;group&gt; &lt;item android:id="@+id/nav_setting" android:icon="@drawable/ic_settings" android:title="@string/setting" /&gt; &lt;/group&gt; &lt;/menu&gt; &lt;/item&gt;&lt;/menu&gt; ok，经过上面的一系列的操作，我们的布局文件就设置好了，接下来就是在java源码中实现 Thrid java源码实现 实现toolbar在activity中可用 setSupportActionBar(toolbar); 实现menu中item的点击事件 主要是实现navgationView.setNavigationItemSelectedListener()这个方法，代码如下 12345678910111213141516171819202122private void setUpdrawerContent(NavigationView navgationView) &#123; navgationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(MenuItem item) &#123; selectDrawerItem(item); return true; &#125; &#125;); &#125;private void selectDrawerItem(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.nav_today_photo: controlShowFragment(0); break; case R.id.nav_more_photo: controlShowFragment(1); break; &#125; item.setChecked(true); toolbar.setTitle(item.getTitle()); &#125; 完成这一步我们的item就可一响应事件了,响应事件其实大多数时候我们也是进行内容区域的切换，这里我实现了Fragment的切换，主要代码如下所示： 12345678910111213141516171819202122232425262728private void controlShowFragment(int position) &#123; FragmentManager fm = getSupportFragmentManager(); FragmentTransaction ft = fm.beginTransaction(); Fragment oldFragment = fm.findFragmentByTag(makeTag(mCurrentPosition)); if (oldFragment != null) &#123; if (position == 0) &#123; if (fm.getBackStackEntryCount() != 0) &#123; fm.popBackStack(); &#125; &#125; ft.hide(oldFragment); &#125; mCurrentPosition = position; Fragment currentFagment = fm.findFragmentByTag(makeTag(position)); if (currentFagment != null) &#123; ft.show(currentFagment); &#125; else &#123; if (position != 0) &#123; ft.addToBackStack(makeTag(position)); &#125; ft.add(R.id.frame_content, getFragment(position), makeTag(position)); &#125; ft.commitAllowingStateLoss(); if (drawerLayout.isShown()) &#123; drawerLayout.closeDrawers(); &#125; &#125; 这里完成这两步基本上，就快大功告成了 Four 和toolbar绑定，实现汉堡菜单动画效果平时我们在使用google家的app的时候可以看到当我们的侧滑滑动的时候toolbar的汉堡菜单有一个动画效果这里我们需要用到ActionBarDrawerToggle这个类，实现如下 DrawerLayout 和 Toolbar进行绑定 123mDrawerToggle = setUpdrawerToggle();//DrawerLayout和ActionBarDrawerToggle进行事件绑定drawerLayout.addDrawerListener(mDrawerToggle); 实例化ActionBarDrawerToggle 123&lt;!-- 资源文件strings.xml中定义如下两个string --&gt; &lt;string name="open_content_drawer"&gt;Open the main menu&lt;/string&gt; &lt;string name="close_content_drawer"&gt;Close the main menu&lt;/string&gt; 1234private ActionBarDrawerToggle setUpdrawerToggle() &#123; return new ActionBarDrawerToggle(this, drawerLayout, toolbar, R.string.open_content_drawer, R.string.close_content_drawer); &#125; 同步状态 当app的屏幕重新加载或者配置改变之后，我们需要DrawerToggle的状态同步 12345678910111213@Override public void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); // Pass any configuration change to the drawer toggles mDrawerToggle.onConfigurationChanged(newConfig); &#125; @Override protected void onPostCreate(@Nullable Bundle savedInstanceState) &#123; super.onPostCreate(savedInstanceState); // Sync the toggle state after onRestoreInstanceState has occurred. mDrawerToggle.syncState(); &#125; Five 最终步骤重写onOptionsItemSelected(MenuItem item)方法，实现当点击actionbar的home/up时可以关闭，开启drwaer(侧滑栏)ActionBarDrawerToggle可以响应事件,代码如下 1234567891011@Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case android.R.id.home: drawerLayout.openDrawer(GravityCompat.START); return true; &#125; //允许ActionBarDrawerToggle处理事件 return mDrawerToggle.onOptionsItemSelected(item) || super.onOptionsItemSelected(item); &#125; 重写onBackPressed()方法 1234567891011121314151617@Override public void onBackPressed() &#123; //当drawerLayout开启时，按backUp键时关闭drawerLayout if (drawerLayout.isDrawerOpen(GravityCompat.START)) &#123; drawerLayout.closeDrawers(); return; &#125; //管理fragment栈(非必须) if (getSupportFragmentManager().getBackStackEntryCount() &gt; 0) &#123; mCurrentPosition--; getSupportFragmentManager().popBackStack(); navgationView.setCheckedItem(navgationView.getMenu().getItem(mCurrentPosition).getItemId()); toolbar.setTitle(navgationView.getMenu().getItem(mCurrentPosition).getTitle()); &#125; else &#123; super.onBackPressed(); &#125; &#125; Six 其他一些细节处理进入app默认选择第一个1navgationView.setCheckedItem(navgationView.getMenu().getItem(0).getItemId());//默认首先选中第一个 headerLayout布局获得 1View hedaderView = navgationView.getHeaderView(0); 第三方依赖 MaterialDrawer NavigationDrawerMaterial 最终实现效果 源码地址源码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio 快捷键]]></title>
      <url>%2F2016%2F04%2F24%2Fandroid%20stduio-smartkey%2F</url>
      <content type="text"><![CDATA[纸上得来终觉浅，绝知此事要躬行 android studio也用了这么久了可是有的快捷键就是记不住，这里做一个常用快捷键的笔记 不定期更新 表1. 部分实用工具窗口和键盘快捷键 工具窗口 Windows和linux Mac 项目 Alt + 1 Command + 1 版本 Alt + 9 Command + 9 运行 Shift + F10 Command + R 调试 Shift + F9 Command + D Android Monitor Alt + 6 Command + 6 返回至编辑 Esc Esc 隐藏所有工具窗口 Control + Shift + F12 Command + Shift + F12 表2. 通用快捷键 描述 Windows和linux Mac 保存所有 Control + S Command + S ` 同步 Control + Alt + Y Command + Option + Y 检查当前文件下的配置 Alt + Shift + I Control + Command + I 添加到喜欢 Alt + Shift + F Option + Shift + F 切换配置 Control + ` Control + ` 打开设置 Control + Alt + S Command + , 打开项目结构 Control + Shift + Alt + S Command + ; 切换编辑和工具窗 Control + Tab Control + Tab 表3. 在Studio导航和搜索快捷键 描述 Windows和linux Mac 全局搜索 按两下Shift 按两下Shift 查找 Control + F Command + F 查找下一个 F3 Command + G 查找前一个 Shift + F3 Command + Shift + G 替换 Control + R Command + R 查找动作 Control + Shift + A Command +Shift + A 通过简单名搜索 Control + Shift + Alt + N Command + Option + O 查找类 Control + N Command + O 查找文件 Control + Shift + N Command + Shift + O 弹出文件结构 Control + F12 Command + F12 打开的编辑文件之间导航 Alt + Right/Left Arrow Control + Right/Left Arrow 跳到源码 F4 / Control + Enter F4 / Command + Down Arrow 在新窗口打开最近编辑文件 Shift + F4 Shift + F4 最近打开文件弹窗 Control + E Command + E 最近编辑文件弹窗 Control + Shift + E Command + Shift + E 打开上一个编辑处 Control + Shift + Bacspace Command + Shift + Bacspace 关闭活跃窗口 Control + F4 Command + W 隐藏活动的或者上一个活动的工具窗 Shift + Esc Shift + Esc 去到某一行 Control + G Command + L 打开类型的继承结构 Control + H Control + H 打开方法层次结构 Control + Shift + H Command + Shift + H 打开回调层次结构 Control + Alt + H Control + Option + H]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android ListView的学习]]></title>
      <url>%2F2016%2F04%2F24%2Flistview%2F</url>
      <content type="text"><![CDATA[学而时习之不亦说乎 ListView要说也用过不少了，这里再将其剔除来,做一个模仿qq的聊天列表，也算作是复习了。 First 创建ListView布局1234&lt;ListView android:id="@+id/test_list" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; second 实现item布局12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:padding="@dimen/activity_horizontal_margin"&gt; &lt;ImageView android:id="@+id/left_image" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/ic_launcher"/&gt; &lt;TextView android:id="@+id/tv_title" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignTop="@id/left_image" android:layout_toRightOf="@id/left_image" android:paddingLeft="10dp" android:text="title" android:textSize="20sp" android:textStyle="bold"/&gt; &lt;TextView android:id="@+id/tv_content" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignBottom="@id/left_image" android:layout_toRightOf="@id/left_image" android:paddingLeft="10dp" android:text="content" /&gt; &lt;TextView android:id="@+id/tv_time" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentRight="true" android:layout_alignTop="@+id/tv_title" android:paddingLeft="10dp" android:text="12:00" /&gt;&lt;/RelativeLayout&gt; 效果如图 新建实体类用来作为Adapter的适配类型123456789101112131415161718192021222324252627282930313233343536373839public class Item &#123; private String title; private String content; private String time; private int imageId; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public String getTime() &#123; return time; &#125; public void setTime(String time) &#123; this.time = time; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public int getImageId() &#123; return imageId; &#125; public void setImageId(int imageId) &#123; this.imageId = imageId; &#125;&#125; 构建Adapter类Adapter ListView和数据源之间的中间人,使用Adapter为ListViwe绑定数据 Adapter * 数据进入可见区域时 * Adapter getView() 方法得到调用 * 返回代表具体数据的视图 * lisview触摸滚动时，可以频繁的调用 * 支持成百上千的数据 当ListView滑动时的一个大概的过程 写一个 MyAdapter 的类继承BaseAdapter，BaseAdapter实现了ListAdapter和SpinnerAdapter中的方法当我们继承他时必须要复写以下四个方法 1. getCount() 返回数据集合的大小 2. getItem() 返回与数据项相关联项的数据 3. getItemId() 返回item的Id 4. getView() 返回代表具体数据的视图 getView()的几种重写 最没效率的写法 123456789101112public View getView(int position, View convertView, ViewGroup parent) &#123; convertView = mInflater.inflate(R.layout.list_item, null); ImageView imageView = (ImageView) convertView.findViewById(R.id.left_image); TextView title = (TextView) convertView.findViewById(R.id.tv_title); TextView content = (TextView) convertView.findViewById(R.id.tv_content); TextView time = (TextView) convertView.findViewById(R.id.tv_time); imageView.setImageResource(items.get(position).getImageId()); title.setText(items.get(position).getTitle()); content.setText(items.get(position).getContent()); time.setText(items.get(position).getTime()); return convertView;&#125; 利用convertView，提升效率的写法 123456789101112131415public View getView(int position, View convertView, ViewGroup parent) &#123; if (convertView == null) &#123; convertView = mInflater.inflate(R.layout.list_item, null); &#125; ImageView imageView = (ImageView) convertView.findViewById(R.id.left_image); TextView title = (TextView) convertView.findViewById(R.id.tv_title); TextView content = (TextView) convertView.findViewById(R.id.tv_content); TextView time = (TextView) convertView.findViewById(R.id.tv_time); imageView.setImageResource(items.get(position).getImageId()); title.setText(items.get(position).getTitle()); content.setText(items.get(position).getContent()); time.setText(items.get(position).getTime()); return convertView;&#125; 这里先判断了一次convertView,如果convertView为空的话，就使用LayoutInflater加载布局，否则就直接复用convertView，这么写就会大大提升效率，现在快速滑动时已经大大的比上一个写法流畅了，虽然不用每次都加载布局了,但是我们每次都还要findViewById()来获取控件的实例，所以我们可以采取下面的写法，再来对效率进行一次提升 利用ViewHolder 飞速提升效率 12345678910111213141516171819202122232425262728public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if (convertView == null) &#123; convertView = mInflater.inflate(R.layout.list_item, null); holder = new ViewHolder(); holder.imageView = (ImageView) convertView.findViewById(R.id.left_image); holder.title = (TextView) convertView.findViewById(R.id.tv_title); holder.content = (TextView) convertView.findViewById(R.id.tv_content); holder.time = (TextView) convertView.findViewById(R.id.tv_time); convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; holder.imageView.setImageResource(items.get(position).getImageId()); holder.title.setText(items.get(position).getTitle()); holder.content.setText(items.get(position).getContent()); holder.time.setText(items.get(position).getTime()); return convertView;&#125;static class ViewHolder&#123; ImageView imageView; TextView title; TextView content; TextView time;&#125; 创建一个内部类ViewHolder,对控件实例进行缓存，然后调用convertView的setTag()方法，将ViewHolder对象存在其中，当convertView不为空时就调用getTag()方法将ViewHolder取出，因为所有控件都在ViewHoler中缓存了,所以就不要再findViewById()来获取控件实例了。 构造函数的编写继承了BaseAdapter光重写上述四个方法可不行，还需要创建一个构造方法,将Context传入，和我们构造的数据List集合 1234public MyAdapter(Context context, List&lt;Item&gt; items) &#123; this.mInflater = LayoutInflater.from(context); this.items = items;&#125; 这里通过传来的contex来获取一个LayoutInflater对象，并以此来加载布局。 在activi中的实现1234567891011121314151617181920protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.listview_layout); ListView listView = (ListView) findViewById(R.id.test_list); final List&lt;Item&gt; mData = new ArrayList&lt;&gt;(); Item item = new Item(); //实例化adapter MyAdapter adapter = new MyAdapter(this, mData); //创建原数据 for (int i = 0; i &lt; 100; i++) &#123; item.setContent("吃饭么？"); item.setTitle("小明"); item.setTime("7:00"); item.setImageId(R.mipmap.ic_launcher); mData.add(item); &#125; //listview绑定adapter listView.setAdapter(adapter); &#125; 处理item的点击事件这里实现setOnItemClickListener()即可实现 1234567listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; Toast.makeText(MyActivity.this, mData.get(position).toString(), Toast.LENGTH_SHORT).show(); Log.d("TAG", String.valueOf(position)); &#125; &#125;); 最终效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Broadcast receiver学习笔记]]></title>
      <url>%2F2016%2F04%2F17%2Ffirstcode-learn-broadcast-reciver%2F</url>
      <content type="text"><![CDATA[行者，始于足下 android中的广播类型 标准广播(Nomal broadcasts) 完全的异步，广播发出之后，所有的广播接收器会同时接受到这条广播消息 执行流程图 有序广播(Ordered broadcastes) 同步执行的广播，广播发出后，同一时刻只会有一个广播接收器接收到消息，只有当前的广播接收器逻辑执行完了，才会传递 广播执行具有先后顺序，按照优先级的高低传递 执行流程图 接收广播系统Android内置了很多系统级别的广播，应用程序可以通过监听这些广播来得到各种系统的信息状态 广播接收器(Broadcaste receiver)要接受到发送的广播，就需要用到广播接收器，广播接收器可用于对我们所感兴趣的广播进行注册。注册过后的广播在广播接收器中就能接受到此广播发送的消息 注册方式一般有两种：在代码中注册和在AndroidManifest.xml中注册即动态注册和静态注册 动态注册 创建广播接收器 新建类继承BroadcastReceiver重写onReceive()方法。 onReceive()在广播消息来时执行，我们对于广播逻辑的处理就在这个方法中进行。 代码中动态注册广播 第一步需要有IntentFilter 实例用于发送所要传递的广播消息 第二步实例化 我们创建的广播接收器 第三步调用registerReceiver()方法传入我们的广播接收器实例和IntentFilter实例 第四步取消注册调用unregisterReceiver()方法取消我们刚才注册的广播 动态注册只有在程序启动后才能接收广播 静态注册 在AndroidManifest.xml 中注册静态广播 &lt;receiver&gt;标签中注册和注册activity类似 是系统级别的不启动系统也能接受到广播 注: onReceive()方法中不允许有耗时操作也不要添加过多的逻辑代码 发送自定义广播 发送标准广播 定义广播接收器接收广播 自定义IntentFilter action 调用sendBroadcast()方法发送自定义的意图 发送有序广播 调用sendOrderedBroadcast()发送有序广播 可设置广播接收器的优先级，可使优先级高的先接收到广播 android:priotity属性设置优先级 在广播接收器中可调用abortBroadcast()截断有序广播 使用本地广播 使用全局广播，安全性不是很好，因此可以使用发送本地广播 只接受本应用程序发送的广播 使用LodalBroadcastManager 对广播进行管理 使用getInstance(context)获取实例化 local.sendBroadcast()发送本地广播 local.registerReceiver()注册本地广播接收器 注：本地广播只可以通过动态注册完成接收]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用阿里云做ss代理中转]]></title>
      <url>%2F2016%2F04%2F09%2Fss-1%2F</url>
      <content type="text"><![CDATA[要么不做，要么就做到最好 自从学校机房被烧了以后，学校的校园网就变得有点龟速了，昨天搭建的ss服务器的速度，不是那么的让人满意，然后看到官方文档可以用haproxy vps做中转也就是试了一下.测试服务器 Ubuntu server 14.04 原理是样 Client &lt;--&gt; 阿里云 vps &lt;--&gt; US VPS Step1 安装 haproxysudo apt-get update sudo apt-get install haproxy Step2 配置 haproxyvim /etc/default/haproxy 设置ENABLED=1 修改配置文件`vim /etc/haproxy/haproxy.cfg` 1234567891011121314151617global ulimit-n 51200defaults log global mode tcp option dontlognull contimeout 1000 clitimeout 150000 srvtimeout 150000frontend ss-in bind *:8388 default_backend ss-outbackend ss-out server server1 US_VPS_IP:8388 maxconn 20480 在Ubuntu的haproxy 不止这些参数，但只要这些就够了 启动haproxy 看到[ok]就可以了 server haproxy start 然后在ss客户端改成你的国内服务器ip就ok了 测试图这里就不上了，运行良好，Android developer 秒开 顺便说一句，如果你只想你的ss代理分享只能在局域网下使用的话，那么你就把上面的代理服务器，设为你在本地的一台服务器或者虚拟机。然后将客户端的服务器ip设为本地服务器的ip即可实现局域网访问了 个人也是刚接触这个若有错误，欢迎指正]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CentOs ss代理服务器搭建]]></title>
      <url>%2F2016%2F04%2F09%2Fss-0%2F</url>
      <content type="text"><![CDATA[文档的阅读，以及实现 继续开坑中，一直在用别人的梯子，这里也尝试着搭建一下自己的ss服务器。 准备一台位于国外的vps,官方推荐Digital Ocean和Linode,我这里用的是Digital Ocean的vps,系统是CentOs 6.7x64。 安装123yum updateyum install python-setuptools &amp;&amp; easy_install pippip install shadowsocks 使用 用命令行启动 格式： ssserver -p 端口号 -k 密码 -m 加密方式 例如: ssserver -p 443 -k password -m aes-256-cfb 在后台运行 sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start 后台运行的停止： sudo ssserver -d stop 后台运行日志的查看： sudo less /var/log/shadowsocks.log 通过配置文件启动 新建一个配置文件: vim /etc/shadowsocks.json 例如： 12345678910&#123; &quot;server&quot;:&quot;my_server_ip&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;mypassword&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false &#125; | 名称| 解释||server| 服务器ip地址||server_port| 服务器监听端口||local_address| 本地ip地址||local_port| 本地端口||password|密码||timeout |超时时间||method|加密方式 默认aes-256-cfb，推荐rc4-md5||fast_open|true或者false linux内核3.7+以上可以开启 fast_open 以降低延迟| 前台运行 ssserver -c /etc/shadowsocks.json 后台运行 ssserver -c /etc/shadowsocks.json -d start ssserver -c /etc/shadowsocks.json -d stop 安装客户端按需索取 这里已Windows配置为例 选择服务器，启动代理。运行结果： 给更多的人使用目前只有Python版和Go语言版支持更多用户 可以在不同的端口设置不同的密码，例如这样： 1234567891011&#123; &quot;server&quot;: &quot;0.0.0.0&quot;, &quot;port_password&quot;: &#123; &quot;8381&quot;: &quot;foobar1&quot;, &quot;8382&quot;: &quot;foobar2&quot;, &quot;8383&quot;: &quot;foobar3&quot;, &quot;8384&quot;: &quot;foobar4&quot; &#125;, &quot;timeout&quot;: 300, &quot;method&quot;: &quot;aes-256-cfb&quot;&#125; 支持的加密方式上面的配置文件中有一个method(加密方式),下面是他支持的加密方式 SSL library RC4-MD5 Salsa20, Chacha20 安装 M2Crypto 提升加密速度 yum install m2crypto rc4-md5 为推荐的加密方式 salsa20 and chacha20salsa20 和 chacha20 是更快的流加密方式，比rc4更快 要使用这两种加密方式要安装 libsodium&gt;=1.0.0 123456sudo wget https://download.libsodium.org/libsodium/releases/libsodium-1.0.10.tar.gztar -xf libsodium-1.0.10.tar.gzcd libsodium-1.0.10sudo make -j2sudo make installsudo ldconfig 不推荐的加密方式 rc4 des-cfb table salsa20-ctr 个人也是刚接触这个若有错误，欢迎指正]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android sdk 镜像搭建]]></title>
      <url>%2F2016%2F04%2F08%2Fandroid-sdk-mirror%2F</url>
      <content type="text"><![CDATA[不尝试，怎么知道不可以呢？ 起源昨天实验室，学长突然交代了我个任务去完成。也就是在局域网环境下，搭建一个android sdk 镜像源。其实吧，乍一听到这个任务确实挺懵逼的，从来没做过这事儿完全不知道如何入手。 解决过程少年莫慌，一切肯定都有解决的办法。首先，我在某个技术群里提出了我的想法，然后有人给我方案是rsync,也有人给我的方案是，搭一个翻墙代理，不过后来这些想法都被我否决了。第一我并不知道google 的sdk源支持不支持rsync,然后若是翻墙代理那么这个成本也太高了，失去了搭建这个的意义。然后开始了不断google的过程，经过搜索关键字的不断更换，我发现了这么一篇博客Android SDK镜像服务器搭建和我的需求竟是如此的雷同。按照博客的介绍。来到了中科院开源镜像小组首先fork了这个项目，接着clone到本地进行研究。其中有两个文件是需要我们注意的第一个是android.py第二个是nginx配置文件总的来说就是这些东西了。 我的搭建过程 linux 服务器的搭建，50g大小的磁盘最好,这里我用的是virtual box创建了ubuntu-server 版的系统(这一步略简单，网上教程很多) nginx 的安装 推荐教程 How To Set Up nginx Virtual Hosts 搭建梯子，用于android sdk 源的下载这里我用的是Shadowsocks 这个就不多说了 运行android.py脚本这里时间可能有点长，毕竟下载的东西比较多 下载完成之后， nginx 服务器的配置，照葫芦画瓢，之接改一下中科院的那个配置文件就ok,主要是 123server_name: your ip adrees or host dl.google.com dl-ssh.google.com; 这一行的注意，其余的照着写下来配置就ok了。其实网上的nginx配置的教程也很多，不理解的可以自行goole详细过程 配置完成重启服务器，写个定时启动脚本okcrontab 定时任务 回到我们的开发电脑 打开android sdk manager配置如下，这是我的虚拟机ip地址 测试结果 总结其实这就是，拿别人轮子来用的一个过程。我认为的注意下这几个点就好了 如何越过gfw,这是最关键的一步，一般来说设置个代理就好了 nginx的配置注意第5点说的那个地方也就可以了 定期到用到的轮子那边看看是否有所更新]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开篇]]></title>
      <url>%2F2016%2F03%2F31%2Ffirst-blog%2F</url>
      <content type="text"><![CDATA[这里是关于这个博客的开篇，折腾过wordpress，最终还是选择了以这种形式搭建博客 一些说明 其实也用过了一些的博客产品，但总觉得不如自己搭建的爽，尝试过用阿里云搭建WordPress过，由于个人懒得去折腾wordpress的一些配置，优化，最终还是放弃了折腾。转而寻求一种简单的配置，结果github pages 恰巧是我想要的。折腾了几天，借助于jekyll，也就将这个静态博客搭建起来了。各种效果也达到了自己所想的。 关于这个博客，域名是自己在万网上买的已经备案了，主题用的是github 上一个开源的 关于主题地址戳这儿 &gt;&gt;Hux 更新说明 由于之前电脑装不上node所以选择了jekyll，不过通过前一段时间的折腾把node装上了所以也就切换到了hexo上面来 现在的博客基于hexo主题是next]]></content>
    </entry>

    
  
  
</search>
